cancer <- read.csv("Cancer.csv")
View(cancer)
cancer <- read.csv("Cancer.csv")
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
cancer <- read.csv("Cancer.csv")
scale <- function(x) {
(x - min(x))/(max(x) - min(x))
}
View(cancer)
scale <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer <- read.csv("Cancer.csv")
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer$diagnosis_result <- ifelse(cancer$diagnosis_result == "M", 0, ifelse(cancer$diagnosis_result == "B", 1, cancer$diagnosis_result))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
View(cancer)
fm <- formula(diagnosis_result ~ .)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 3,
linear.output = F, err.fct = "ce")
View(train)
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 3,
linear.output = F, err.fct = "ce")
plot(model_nn)
nn_simple$result.matrix
model_nn$result.matrix
summary(model_nn)
model_nn
pred_nn <- predict(model_nn, newdata = test, type = "prob")
pr_nn <- prediction(pred[, 2], test$diagnosis_result)
pred_nn <- predict(model_nn, newdata = test, type = "prob")
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 3,
linear.output = F, err.fct = "ce")
pred_nn <- predict(model_nn, newdata = test, type = "prob")
plot(model_nn)
plot(model, length = 0.1)
plot(model_nn, length = 0.1)
plot(model_nn)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(4, 4), rep = 4,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
plot(model_nn, length = 0.1)
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(4, 4, 4, 4), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(4, 5, 3, 4), rep = 4,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(4, 5), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(5), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(5, 5), rep = 4,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
cancer <- read.csv('cancer.csv')
cancer1 <- as.data.frame(scale(cancer[,-9]))
cancer_scaled <- data.frame(cancer1, diagnosis_result = cancer$diagnosis_result)
cancer_scaled$diagnosis_result <- as.numeric(factor(cancer_scaled$diagnosis_result, levels = c('M','B'), labels = c(1,0)))
train_indeces <- createDataPartition(cancer$diagnosis_result, p = 0.8, list = F)
train <- cancer_scaled[train_indeces,]
test <- cancer_scaled[-train_indeces,]
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension, data = train1)
model1 <- neuralnet(fm, data = train, hidden = c(3,3), err.fct = "ce", linear.output = F, rep = 4)
plot(model, length = 0.1)
model1 <- neuralnet(fm, data = train, hidden = c(3,3), err.fct = "ce", linear.output = F, rep = 4)
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension, data = train1)
model1 <- neuralnet(fm, data = train, hidden = c(3,3), err.fct = "ce", linear.output = F, rep = 4)
cmpt <- compute(model, test[,-9], rep = 1)
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension, data = train1)
model1 <- neuralnet(fm, data = train, hidden = c(3,3), err.fct = "ce", linear.output = F, rep = 4)
cancer <- read.csv('cancer.csv')
cancer1 <- as.data.frame(scale(cancer[,-9]))
cancer_scaled <- data.frame(cancer1, diagnosis_result = cancer$diagnosis_result)
cancer_scaled$diagnosis_result <- as.numeric(factor(cancer_scaled$diagnosis_result, levels = c('M','B'), labels = c(1,0)))
train_indeces <- createDataPartition(cancer$diagnosis_result, p = 0.8, list = F)
train <- cancer_scaled[train_indeces,]
test <- cancer_scaled[-train_indeces,]
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension, data = train1)
model1 <- neuralnet(fm, data = train, hidden = c(3,3), err.fct = "ce", linear.output = F, rep = 4)
plot(model, length = 0.1)
cmpt <- compute(model, test[,-9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[,1], test$diagnosis_result)
performance(p_test,"auc")@y.values
library(class)
train <- cancer[train_indeces,]
performance(p_test,"auc")@y.values
## libraries that may be needed
library(ROCR)
library(caret)
library(neuralnet)
library(ggplot2)
# 1. Load data. Prepare training and testing sets (80%/20%).
# Make all the required preprocessing for building the
# neuralnetwork model. (10)
cancer <- read.csv("Cancer.csv")
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer$diagnosis_result <- ifelse(cancer$diagnosis_result == "M", 0, ifelse(cancer$diagnosis_result == "B", 1, cancer$diagnosis_result))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
# 2. Build the neural network model. Play with the parameters
# in order to get as high accuracy as possible. Report the
# final accuracy. Plot the model, make sure you do not have
# overlapping objects in the plot.  (20)
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
## accuracy 0.8131
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 4,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4), rep = 7,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4), rep = 7,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
model_knn <- knn(train[,1:8], test[,1:8], train$diagnosis_result, k = 12, prob = T)
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train_new <- cancer[index,]
test_new <- cancer[-index,]
model_knn <- knn(train[,1:8], test[,1:8], train$diagnosis_result, k = 12, prob = T)
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:10))
model_knn <- knn(train[, -9], test[, -9], train$diagnosis_result, k = 12, prob = T)
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
model_knn <- knn(train[, -9], test[, -9], train$diagnosis_result, k = 5, prob = T)
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
model_knn <- knn(train[, -9], test[, -9], train_new$diagnosis_result, k = 5, prob = T)
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
fit_knn$results
model_knn <- knn(train[, -9], test[, -9],
train_new$diagnosis_result,
k = 11, prob = T)
knn_probs <- predict(knnFit, newdata = test, type = 'prob')
knn_probs <- predict(model_knn, newdata = test, type = 'prob')
knn_probs <- predict(model_knn, newdata = test_new, type = 'prob')
library(class)
library(ROCR)
library(caret)
library(neuralnet)
library(ggplot2)
cancer <- read.csv("Cancer.csv")
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer$diagnosis_result <- ifelse(cancer$diagnosis_result == "M", 0, ifelse(cancer$diagnosis_result == "B", 1, cancer$diagnosis_result))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test,"auc")@y.values
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train_new <- cancer[index,]
test_new <- cancer[-index,]
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
View(train_new)
View(test_new)
cancer <- read.csv("Cancer.csv")
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer$diagnosis_result <- ifelse(cancer$diagnosis_result == "M", 0, ifelse(cancer$diagnosis_result == "B", 1, cancer$diagnosis_result))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
cancer <- read.csv("Cancer.csv")
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train_new <- cancer[index,]
test_new <- cancer[-index,]
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:30))
fit_knn$results
fit_knn$bestTune
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:50))
fit_knn$bestTune
fit_knn$results
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:20))
fit_knn$results
fit_knn$bestTune
model_knn <- knn(train[, -9], test[, -9],
train_new$diagnosis_result,
k = 8, prob = T)
model_knn <- knn(train_new[, -9], test_new[, -9],
train_new$diagnosis_result,
k = 8, prob = T)
probs <- predict(model_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[,2], test$diagnosis_result)
probs <- predict(model_knn, newdata = test_new, type = 'prob')
probs <- predict(fit_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[,2], test$diagnosis_result)
p_test_new <- prediction(probs[,2], test_new$diagnosis_result)
p_test_new <- prediction(probs[,2], test_new$diagnosis_result)
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
cancer <- read.csv("Cancer.csv")
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train_new <- cancer[index,]
test_new <- cancer[-index,]
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:20))
fit_knn$results
fit_knn$bestTune
fit_knn$results
fit_knn$bestTune
train_new[, 9]
model_knn <- knn(train_new[, -9], test_new[, -9],
train_new$diagnosis_result,
k = 8, prob = T)
probs <- predict(fit_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
performance(P_Test, 'auc')@y.values
performance(p_test_new, 'auc')@y.values
probs$M
p_test_new <- prediction(probs, test_new$diagnosis_result)
probs <- predict(fit_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
diabetes <- read.csv("Diabetes.csv")
for(x in 1:8) {
diabetes[, x] <- sc(diabetes[, x])
}
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
for(x in 1:8) {
diabetes[, x] <- sc(diabetes[, x])
}
index <- createDataPartition(diabetes$Class, p=0.8, list=F)
index <- createDataPartition(diabetes$Class, p=0.8, list=F)
train <- diabetes[index,]
test <- diabetes[-index,]
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
diabetes <- read.csv("Diabetes.csv")
for(x in 1:8) {
diabetes[, x] <- sc(diabetes[, x])
}
index <- createDataPartition(diabetes$Class, p=0.8, list=F)
train_diab <- diabetes[index,]
test_diab <- diabetes[-index,]
View(train_diab)
fm <- formula(Class ~ NTS+PGC+DBP+TSFT+INS+BMI+DPF+Age)
model_nn_new <- neuralnet(fm, data = train_diab, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
model_nn_new <- neuralnet(fm, data = train_diab, hidden = c(3, 4, 3), rep = 3,
linear.output = F, err.fct = "ce")
plot(model_nn_new, length = 0.1)
cmpt_diab <- compute(model_nn, test_diab[, -9], rep = 1)
cmpt_diab <- compute(model_nn_new, test_diab[, -9], rep = 1)
p_test_diab <- ROCR::prediction(cmpt$net.result[, 1], test_diab$Class)
performance(p_test_diab, "auc")@y.values
p_test_diab <- ROCR::prediction(cmpt_diab$net.result[, 1], test_diab$Class)
cmpt_diab <- compute(model_nn_new, test_diab[, -9], rep = 1)
is.numeric(train_diab$Class)
model_nn_new <- neuralnet(fm, data = train_diab, hidden = c(3, 3), rep = 3,
linear.output = F, err.fct = "ce")
plot(model_nn_new, length = 0.1)
cmpt_diab <- compute(model_nn_new, test_diab[, -9], rep = 1)
p_test_diab <- ROCR::prediction(cmpt_diab$net.result[, 1], test_diab$Class)
performance(p_test_diab, "auc")@y.values
class_nn<-ifelse(cmpt_diab$net.result > 0.5, 1,0)
class_nn
performance(p_test_diab, "auc")@y.values
confusionMatrix(class_nn, test_diab$Class, positive = "1")
class_nn_diab <- ifelse(cmpt_diab$net.result > 0.5, 1,0)
confusionMatrix(class_nn_diab, test_diab$Class, positive = "1")
library(class)
library(ROCR)
library(caret)
library(neuralnet)
library(ggplot2)
cancer <- read.csv("Cancer.csv")
sc <- function(x) {
(x - min(x))/(max(x) - min(x))
}
for(x in 1:8) {
cancer[, x] <- sc(cancer[, x])
}
cancer$diagnosis_result <- ifelse(cancer$diagnosis_result == "M", 0, ifelse(cancer$diagnosis_result == "B", 1, cancer$diagnosis_result))
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train <- cancer[index,]
test <- cancer[-index,]
fm <- formula(diagnosis_result ~ radius+texture+perimeter+area+smoothness+compactness+symmetry+fractal_dimension)
model_nn <- neuralnet(fm, data = train, hidden = c(3, 4, 3), rep = 7,
linear.output = F, err.fct = "ce")
plot(model_nn, length = 0.1)
cmpt <- compute(model_nn, test[, -9], rep = 1)
p_test <- ROCR::prediction(cmpt$net.result[, 1], test$diagnosis_result)
performance(p_test, "auc")@y.values
class_nn <- ifelse(cmpt$net.result > 0.5, 1,0)
confusionMatrix(class_nn, test$, positive = "1")
confusionMatrix(class_nn, test$diagnosis_result, positive = "1")
class_nn_diab <- ifelse(cmpt_diab$net.result > 0.5, 1,0)
confusionMatrix(class_nn_diab, test_diab$Class, positive = "1")
confusionMatrix(class_nn_diab, test_diab$Class, positive = "1")
confusionMatrix(class_nn_diab, test_diab$Class, positive = "1")
cancer <- read.csv("Cancer.csv")
index <- createDataPartition(cancer$diagnosis_result, p=0.8, list=F)
train_new <- cancer[index,]
test_new <- cancer[-index,]
ctrl <- trainControl(method = "repeatedcv",
number = 10, repeats = 5,
classProbs = TRUE,
summaryFunction = twoClassSummary)
fit_knn <- train(diagnosis_result ~ ., data = train_new, method = "knn",
trControl = ctrl,
preProcess = c("center","scale"),
tuneGrid = expand.grid(k = 3:20))
fit_knn$results
fit_knn$bestTune
model_knn <- knn(train_new[, -9], test_new[, -9],
train_new$diagnosis_result,
k = 8, prob = T)
probs <- predict(fit_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
performance(p_test_new, "auc")@y.values
probs <- predict(fit_knn, newdata = test_new)
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
performance(p_test_new, "auc")@y.values
library(pROC)
probs <- predict(fit_knn, newdata = test_new, type = 'prob')
p_test_new <- prediction(probs[, 2], test_new$diagnosis_result)
performance(p_test_new, "auc")@y.values
p_test_new <- prediction(probs[, 2], diagnosis_result)
p_test_new <- prediction(probs[, 2], diagnosis_result)
